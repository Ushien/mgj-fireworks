#pragma kernel CSParticle

 // Particle's data
struct Particle
{
	float3 position;
    float3 truePosition;
	float3 velocity;
	float life;
};

// Particle's data, shared with the shader
RWStructuredBuffer<Particle> particleBuffer;

// Variables set from the CPU 
float deltaTime;
float2 mousePosition;
float xShift;
float shiftAmount;
float startSize;
float maxDistance;
float timeUpdate;

bool pouring;

uint rng_state;

uint rand_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

void respawn(uint id)
{
    // if(!pouring)
    //     return;
	rng_state = id;
	float tmp = (1.0 / 4294967296.0);
	float f0 = float(rand_xorshift()) * tmp - 0.5;
	float f1 = float(rand_xorshift()) * tmp - 0.5;
	//float f2 = float(rand_xorshift()) * tmp - 0.5;
	float3 normalF3 = normalize(float3(f0, f1, 0.0)) * 0.2f;
	normalF3 *= float(rand_xorshift()) * tmp * startSize;
	//particleBuffer[id].position = float3(normalF3.x + mousePosition.x + sin(timeUpdate*7) * 0.2, normalF3.y + mousePosition.y, 0.0);
	particleBuffer[id].position = float3(normalF3.x + mousePosition.x, normalF3.y + mousePosition.y, 0.0);
    particleBuffer[id].truePosition = particleBuffer[id].position;
    //particleBuffer[id].position = float3(mousePosition.x, mousePosition.y, 0.0);
	// reset the life of this particle
	particleBuffer[id].life = 4;
	particleBuffer[id].velocity = float3((rand_xorshift() * tmp +xShift) * shiftAmount, (rand_xorshift() * tmp +xShift) * shiftAmount, 0);//(rand_xorshift() * tmp + 0.3)* 2, 0);
}

// fonction random
float Rand(uint seed)
{
    seed = (seed << 13U) ^ seed;
    return 1.0f - ((seed * (seed * seed * 15731U + 789221U) + 1376312589U) & 0x7fffffffU) / 1073741824.0f;
}

float RandRange(uint seed, float min, float max)
{
    return lerp(min, max, Rand(seed));
}

[numthreads(256, 1, 1)]
void CSParticle(uint3 id : SV_DispatchThreadID)
{
    Particle particle = particleBuffer[id.x];

    // Kill la particule au delÃ  d'une distance max
    if ((particle.position.y < maxDistance && particle.life != -1) || particle.truePosition.y < maxDistance)
    {
        particle.life = -1;

        // Declare seed before using it
        uint seed = id.x * 12345 + uint(timeUpdate * 1000.0);
        particle.truePosition.y = RandRange(seed, -10.0f, 10.0f);
    }

    float3 dir = float3(0.0, -0.05, 0.0);
    particle.velocity += dir;

    if (particle.life != -1)
    {
        particle.position += particle.velocity * deltaTime;
    }
    else
    {
        particle.truePosition += particle.velocity * deltaTime;
    }

    particleBuffer[id.x] = particle;

    if (particle.life < 0 && pouring && mousePosition.y - particle.truePosition.y < 1.0f)
        respawn(id.x);
}
