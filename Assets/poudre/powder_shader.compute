#pragma kernel CSParticle

 // Particle's data
struct Particle
{
	float3 position;
    float3 truePosition;
	float3 velocity;
	float life;
    int2 type;
};

// Particle's data, shared with the shader
RWStructuredBuffer<Particle> particleBuffer;
RWStructuredBuffer<uint> addedCounter; // communique le nombre de particules ajoutées

// Variables set from the CPU 
float deltaTime;
float2 mousePosition;
float xShift;
float shiftAmount;
float startSize;
float maxDistance;
float timeUpdate;
int selectedIndex;
float yBoxMax;
float xBoxMin;
float xBoxMax;

bool pouring;

uint rng_state;

uint rand_xorshift()
{
	// Xorshift algorithm from George Marsaglia's paper
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

void respawn(uint id)
{
    particleBuffer[id].type[0] = particleBuffer[id].type[1];
	rng_state = id;
	float tmp = (1.0 / 4294967296.0);
	float f0 = float(rand_xorshift()) * tmp - 0.5;
	float f1 = float(rand_xorshift()) * tmp - 0.5;
	//float f2 = float(rand_xorshift()) * tmp - 0.5;
	float3 normalF3 = normalize(float3(f0, f1, 0.0)) * 0.2f;
	normalF3 *= float(rand_xorshift()) * tmp * startSize;
	//particleBuffer[id].position = float3(normalF3.x + mousePosition.x + sin(timeUpdate*7) * 0.2, normalF3.y + mousePosition.y, 0.0);
	particleBuffer[id].position = float3(normalF3.x + mousePosition.x, normalF3.y + mousePosition.y, 0.0);
    particleBuffer[id].truePosition = particleBuffer[id].position;
    //particleBuffer[id].position = float3(mousePosition.x, mousePosition.y, 0.0);
	// reset the life of this particle
	particleBuffer[id].life = 4;
	particleBuffer[id].velocity = float3((rand_xorshift() * tmp +xShift) * shiftAmount, (rand_xorshift() * tmp +xShift) * shiftAmount, 0);//(rand_xorshift() * tmp + 0.3)* 2, 0);
}

// fonction random
float Rand(uint seed)
{
    seed = (seed << 13U) ^ seed;
    return 1.0f - ((seed * (seed * seed * 15731U + 789221U) + 1376312589U) & 0x7fffffffU) / 1073741824.0f;
}

float RandRange(uint seed, float min, float max)
{
    return lerp(min, max, Rand(seed));
}

[numthreads(256, 1, 1)]
void CSParticle(uint3 id : SV_DispatchThreadID)
{
    Particle particle = particleBuffer[id.x];
    particle.type[1] = selectedIndex;

    // Si la particule arrive à gauche de la fusée, elle rebondit
    if (particle.position.y <= yBoxMax && abs(particle.position.x - xBoxMax) < 0.1 && particle.velocity.x < 0 )
        particle.velocity.x = - particle.velocity.x;

    // Si la particule touche un bord de la fusée, elle rebondit
    if (abs(particle.position.y - yBoxMax) < 0.1 && (abs(particle.position.x - xBoxMax) < 0.1 || abs(particle.position.x - xBoxMin) < 0.1) && particle.velocity.y < 0) {
        particle.velocity.y = - particle.velocity.y/4; 
        // pour éviter des rebonds infinis
        if(abs(particle.velocity.x) < 0.1 ){
            uint seed = id.x * 12345 + uint(timeUpdate * 1000.0);
            particle.velocity.x = RandRange(seed, -1.0f, 1.0f);
            }
    }

    // Si la particule arrive dans la fusée
    if (particle.position.y < yBoxMax && particle.position.x > xBoxMin && particle.position.x < xBoxMax && particle.life != -1)
    {
        InterlockedAdd(addedCounter[0], 1);
        particle.life = -1;

        // Declare seed before using it
        uint seed = id.x * 12345 + uint(timeUpdate * 1000.0);
        particle.truePosition.y = RandRange(seed, -10.0f, 10.0f);

    }

    // Kill la particule au delà d'une distance max
    if ((particle.position.y < maxDistance && particle.life != -1) || (particle.truePosition.y < maxDistance && particle.life == -1))
    {
        particle.life = -1;

        // Declare seed before using it
        uint seed = id.x * 12345 + uint(timeUpdate * 1000.0);
        particle.truePosition.y = RandRange(seed, -10.0f, 10.0f);
    }

    float3 dir = float3(0.0, -0.05, 0.0);
    particle.velocity += dir;

    if (particle.life != -1)
    {
        particle.position += particle.velocity * deltaTime;
    }
    else
    {
        particle.truePosition += particle.velocity * deltaTime;
    }

    particleBuffer[id.x] = particle;

    if (particle.life < 0 && pouring && mousePosition.y - particle.truePosition.y < 1.0f)
        respawn(id.x);
}
